// object_utils.cpp
// Object utility routines.
// This file was automatically generated by Spritely 

#include <nds.h>

#include "object_utils.h"
#include "sprites.h"

typedef struct {
	int sprite_id;
} ObjectInfo;

typedef struct 
{
	u8 mainScreen; //0 if it's main screen, 1 if sub	
	u16* oam_enum;
	bool updateScreen;

} CurrentScreenInfo;

static CurrentScreenInfo currentScreen = {0, OAM, false};

// This is a shadow copy of the OAM (Object Attribute Memory) that
// we maintain to keep track of our sprites.
// Changes made here are not applied until this is copied into the real
// OAM using UpdateScreen().
static SpriteEntry oam_shadow[kMaxObjects];
static SpriteEntry oam_shadow_sub[kMaxObjects];

//this is the current oam, use switchScreen() to switch the current one
static SpriteEntry* oam_current = oam_shadow;


// Additional information about each object.
static ObjectInfo obj_info[kMaxObjects];
static ObjectInfo obj_info_sub[kMaxObjects];

static ObjectInfo* obj_current = obj_info;

// Initialize the objects in the shadow OAM. By default, all of the sprites are active,
// so we need to disable them.
void InitializeObjects()
{
	for(int k = 0; k < 2; ++k)
	{
		for (int i=0; i < kMaxObjects; ++i) {
			oam_current[i].attribute[0] = ATTR0_DISABLED;
			obj_current[i].sprite_id = 0;
		}
		currentScreen.updateScreen = true;
		SwitchScreenObj();
	}
}

// InitObject
// Update the given object entry in the shadow OAM with info about the specified sprite.
// Call UpdateScreen() after this to see the sprite on the screen.
//
// Parameters:
//   <object> is the index of the object to create
//   <sprite> is the sprite index to use to init the object
//
// See gba_oam.h for more information about how the OAM entries are encoded.
void InitObject(int object, int sprite)
{
	if (object >= kMaxObjects || sprite >= kTotalSprites)
		return;
		
	oam_current[object].attribute[0] = SpriteInfo[sprite].shape | ATTR0_COLOR_16 | OBJ_Y(0);
	oam_current[object].attribute[1] = SpriteInfo[sprite].size | OBJ_X(0);
	oam_current[object].attribute[2] = ATTR2_PALETTE(SpriteInfo[sprite].subpalette_id) | SpriteInfo[sprite].first_tile;
	obj_current[object].sprite_id = sprite;
	currentScreen.updateScreen = true;
}

// Get the sprite currently assigned to this object.
int GetObjectSprite(int object)
{
	if (object >= kMaxObjects)
		return -1;

	return obj_current[object].sprite_id;
}

// Change the sprite associated with this object.
void SetObjectSprite(int object, int sprite)
{
	if (object >= kMaxObjects || sprite >= kTotalSprites)
		return;

	oam_current[object].attribute[0] &= 0x3fff;
	oam_current[object].attribute[0] |= SpriteInfo[sprite].shape;
	oam_current[object].attribute[1] &= 0x3fff;
	oam_current[object].attribute[1] |= SpriteInfo[sprite].size;
	oam_current[object].attribute[2] = ATTR2_PALETTE(SpriteInfo[sprite].subpalette_id) | SpriteInfo[sprite].first_tile;
	obj_current[object].sprite_id = sprite;
	currentScreen.updateScreen = true;
}

// Move the object to the new location, leaving the other object attributes unchanged.
void MoveObjectTo(int object, int x, int y)
{
	if (object >= kMaxObjects)
		return;

	oam_current[object].attribute[0] &= ~OBJ_Y(0xffff);
	oam_current[object].attribute[0] |= OBJ_Y(y);
	oam_current[object].attribute[1] &= ~OBJ_X(0xffff);
	oam_current[object].attribute[1] |= OBJ_X(x);
	currentScreen.updateScreen = true;
}

// Update the objects on the screen by copying the shadow OAM into the real OAM,
void UpdateScreen()
{
	for(int i = 0; i < 2; ++i)
	{
		if (currentScreen.updateScreen)
		{
			DC_FlushRange(oam_current, sizeof(*oam_current));
			dmaCopy((void*)oam_current, currentScreen.oam_enum, sizeof(*oam_current));
			currentScreen.updateScreen = false;
		}
		SwitchScreenObj();
	}
}

void SwitchScreenObj()
{
	if(currentScreen.mainScreen == 0)
	{
		oam_current = oam_shadow_sub;
		obj_current = obj_info_sub;
		currentScreen.mainScreen = 1;
		currentScreen.oam_enum = OAM_SUB;
	}
	else
	{
		oam_current = oam_shadow;
		obj_current = obj_info;
		currentScreen.mainScreen = 0;
		currentScreen.oam_enum = OAM;
	}

	currentScreen.updateScreen=true;
}

void GetObjectLocation(int object, int *px, int *py) {
	if (object >= kMaxObjects)
		return;
	*px = oam_current[object].attribute[1] & OBJ_X(0xffff);
	*py = oam_current[object].attribute[0] & OBJ_Y(0xffff);
}

void GetObjectSize(int object, int *pwidth, int *pheight) {
	if (object >= kMaxObjects)
		return;
	int sprite = obj_current[object].sprite_id;
	*pwidth = SpriteInfo[sprite].width;
	*pheight = SpriteInfo[sprite].height;
}

int GetObjectWidth(int object) {
	if (object >= kMaxObjects)
		return 0;
	int sprite = obj_current[object].sprite_id;
	if (sprite >= kTotalSprites)
		return 0;
	return SpriteInfo[sprite].width;
}

int GetObjectHeight(int object) {
	if (object >= kMaxObjects)
		return 0;
	int sprite = obj_current[object].sprite_id;
	if (sprite >= kTotalSprites)
		return 0;
	return SpriteInfo[sprite].height;
}

void ShowObject(int object, bool show) {
	if (object >= kMaxObjects)
		return;

	if (show)
		oam_current[object].attribute[0] &= ~ATTR0_DISABLED;
	else
		oam_current[object].attribute[0] |= ATTR0_DISABLED;
	currentScreen.updateScreen = true;
}

bool IsObjectVisible(int object) {
	if (object >= kMaxObjects)
		return false;

	return !(oam_current[object].attribute[0] & ATTR0_DISABLED);
}

void FlipObject(int object, bool horizontal, bool vertical) {
	if (object >= kMaxObjects)
		return;

	// Make sure that rotation/scale flag is off.
	oam_current[object].attribute[0] &= ~ATTR0_ROTSCALE;
	
	if (horizontal)
		oam_current[object].attribute[1] |= ATTR1_FLIP_X;
	else
		oam_current[object].attribute[1] &= ~ATTR1_FLIP_X;

	if (vertical)
		oam_current[object].attribute[1] |= ATTR1_FLIP_Y;
	else
		oam_current[object].attribute[1] &= ~ATTR1_FLIP_Y;
	
	currentScreen.updateScreen = true;
}
